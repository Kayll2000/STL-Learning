set 是STL的一种关联式容器，和map不同，set只能存储key和value相同的一组值。
map和set的插入删除效率比用其他序列容器高——对于关联容器来说，不需要做内存拷贝和内存移动。set中所有的元素都是以节点的方式来存储。

iterator相当于指向节点的指针，内存没有变，指向内存的指针不会失效。【为何每次insert之后，以前保存的iterator不会失效？】
在set中查找是使用二分查找[log 2]，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？
最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次

1.初始化 
	set<int> intdata;set<string> 
2.插入insert   
	intdata.insert(1);
3.常用的成员方法
begin()     ,返回set容器的第一个元素的双向迭代器

end() 　　,返回set容器的最后一个元素的双向迭代器

clear()   　,删除set容器中的所有的元素

empty() 　,判断set容器是否为空

max_size()  ,返回set容器可能包含的元素最大个数

size() 　,返回当前set容器中的元素个数

rbegin　,返回的值和end()相同的反向双向迭代器

rend()　,返回的值和rbegin()相同的反向双向迭代器